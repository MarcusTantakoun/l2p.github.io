<!doctype html>
<html class="no-js" lang="en" data-content_root="../../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <!-- Generated with Sphinx 8.2.3 and Furo 2024.08.06 -->
        <title>l2p.utils.pddl_validator - l2p</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?v=302659d7" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">l2p</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  
  <span class="sidebar-brand-text">l2p</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../l2p.html">L2P</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../paper_recreations.html">Paper Recreations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../templates.html">Templates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../types.html">Data Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../paper_feed.html">Paper Feed</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <h1>Source code for l2p.utils.pddl_validator</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains a collection of PDDL syntax validation functions. Users MUST specify what validation checker</span>
<span class="sd">is being used in `error_types` when using an extraction function found in DomainBuilder/TaskBuilder class.</span>

<span class="sd">For instance:</span>
<span class="sd">    syntax_validator = SyntaxValidator()</span>

<span class="sd">    self.syntax_validator.error_types = [</span>
<span class="sd">                &quot;validate_header&quot;,</span>
<span class="sd">                &quot;validate_duplicate_headers&quot;,</span>
<span class="sd">                &quot;validate_unsupported_keywords&quot;,</span>
<span class="sd">                &quot;validate_params&quot;,</span>
<span class="sd">                &quot;validate_types_predicates&quot;,</span>
<span class="sd">                &quot;validate_format_predicates&quot;,</span>
<span class="sd">                &quot;validate_usage_action&quot;,</span>
<span class="sd">            ]</span>

<span class="sd">Is supported in: DomainBuilder.extract_pddl_action(**kwargs, syntax_validator)</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.pddl_format</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.pddl_parser</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.pddl_types</span><span class="w"> </span><span class="kn">import</span> <span class="n">Predicate</span><span class="p">,</span> <span class="n">Function</span>


<span class="n">ORDINAL_SUFFIXES</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;st&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;nd&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;rd&quot;</span><span class="p">}</span>

<span class="c1"># constant declarations for PDDL types</span>
<span class="n">LOGICAL_CONNECTIVES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;and&quot;</span><span class="p">,</span> <span class="s2">&quot;not&quot;</span><span class="p">,</span> <span class="s2">&quot;or&quot;</span><span class="p">,</span> <span class="s2">&quot;imply&quot;</span><span class="p">}</span>
<span class="n">QUANTIFIERS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;forall&quot;</span><span class="p">,</span> <span class="s2">&quot;exists&quot;</span><span class="p">}</span>
<span class="n">CONDITIONAL_EFFECTS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;when&quot;</span><span class="p">}</span>

<span class="n">NUMERIC_OPERATORS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">}</span>
<span class="n">COMPARISON_OPERATORS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;=&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;=&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;=&quot;</span><span class="p">}</span>
<span class="n">ASSIGNMENT_OPERATORS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;assign&quot;</span><span class="p">,</span> <span class="s2">&quot;increase&quot;</span><span class="p">,</span> <span class="s2">&quot;decrease&quot;</span><span class="p">,</span> <span class="s2">&quot;scale-up&quot;</span><span class="p">,</span> <span class="s2">&quot;scale-down&quot;</span><span class="p">}</span>

<span class="c1"># TODO: implement preferences and temporal features</span>
<span class="n">TEMPORAL_KEYWORDS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;at&quot;</span><span class="p">,</span> <span class="s2">&quot;over&quot;</span><span class="p">,</span> <span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="s2">&quot;end&quot;</span><span class="p">}</span>
<span class="n">PREFERENCE_KEYWORDS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;sometime-after&quot;</span><span class="p">,</span>
    <span class="s2">&quot;sometime-before&quot;</span><span class="p">,</span>
    <span class="s2">&quot;always-within&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hold-during&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hold-after&quot;</span><span class="p">,</span>
    <span class="s2">&quot;at end&quot;</span><span class="p">,</span>
<span class="p">}</span>


<div class="viewcode-block" id="SyntaxValidator">
<a class="viewcode-back" href="../../../l2p.html#l2p.utils.pddl_validator.SyntaxValidator">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SyntaxValidator</span><span class="p">:</span>
<div class="viewcode-block" id="SyntaxValidator.__init__">
<a class="viewcode-back" href="../../../l2p.html#l2p.utils.pddl_validator.SyntaxValidator.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">headers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">error_types</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unsupported_keywords</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes an L2P custom syntax validator checker object.</span>

<span class="sd">        Args:</span>
<span class="sd">            headers (list[str]): headers to extract from LLM output</span>
<span class="sd">            error_types (list[str]): error types to execute formalization functions</span>
<span class="sd">            unsupported_keywords (list[str]): keywords to check against LLM output</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># assign default unsupported keywords</span>
        <span class="n">default_unsupported</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;pddl&quot;</span><span class="p">,</span> <span class="s2">&quot;lisp&quot;</span><span class="p">,</span> <span class="s2">&quot;python&quot;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">headers</span> <span class="o">=</span> <span class="n">headers</span> <span class="k">if</span> <span class="n">headers</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error_types</span> <span class="o">=</span> <span class="n">error_types</span> <span class="k">if</span> <span class="n">error_types</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unsupported_keywords</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">default_unsupported</span>
            <span class="k">if</span> <span class="n">unsupported_keywords</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">unsupported_keywords</span>
        <span class="p">)</span></div>


    <span class="c1"># ---- PDDL TYPE CHECKS ----</span>

<div class="viewcode-block" id="SyntaxValidator.validate_type">
<a class="viewcode-back" href="../../../l2p.html#l2p.utils.pddl_validator.SyntaxValidator.validate_type">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">validate_type</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">claimed_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">types</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the claimed_type is valid for the target_type according to the type hierarchy.</span>

<span class="sd">        Args:</span>
<span class="sd">            target_type (str): type that is expected for the parameter (from :predicates)</span>
<span class="sd">            claimed_type (str): type that is provided in the LLM output PDDL.</span>
<span class="sd">            types (dict[str,str] | list[dict[str,str]]): current types in domain</span>

<span class="sd">        Returns:</span>
<span class="sd">            validation_info (tuple[bool,str]): validation info containing pass flag and error message</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check if the claimed type matches the target type</span>
        <span class="k">if</span> <span class="n">claimed_type</span> <span class="o">==</span> <span class="n">target_type</span><span class="p">:</span>
            <span class="n">feedback_msg</span> <span class="o">=</span> <span class="s2">&quot;[PASS]: claimed type matches target type definition.&quot;</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">feedback_msg</span>

        <span class="n">types</span> <span class="o">=</span> <span class="n">format_types</span><span class="p">(</span><span class="n">types</span><span class="p">)</span>  <span class="c1"># flatten hierarchy</span>

        <span class="c1"># extract all types from the keys in the types dictionary</span>
        <span class="n">all_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">types</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">main_type</span><span class="p">,</span> <span class="o">*</span><span class="n">subtype</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; - &quot;</span><span class="p">)</span>
            <span class="n">all_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">main_type</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">subtype</span><span class="p">:</span>
                <span class="n">all_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">subtype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>

        <span class="c1"># check if target type is not found in all types</span>
        <span class="k">if</span> <span class="n">target_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_types</span><span class="p">:</span>
            <span class="n">feedback_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[ERROR]: target type `</span><span class="si">{</span><span class="n">target_type</span><span class="si">}</span><span class="s2">` is not found in :types definition: </span><span class="si">{</span><span class="n">all_types</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">feedback_msg</span>

        <span class="c1"># iterate through the types hierarchy to check if claimed_type is a subtype of target_type</span>
        <span class="n">current_type</span> <span class="o">=</span> <span class="n">claimed_type</span>
        <span class="k">while</span> <span class="n">current_type</span> <span class="ow">in</span> <span class="n">all_types</span><span class="p">:</span>
            <span class="c1"># find the key that starts with the current type</span>

            <span class="n">parent_type_entry</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
                <span class="p">(</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">types</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">current_type</span><span class="si">}</span><span class="s2"> - &quot;</span><span class="p">)),</span> <span class="kc">None</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">parent_type_entry</span><span class="p">:</span>
                <span class="c1"># extract the parent type from the key</span>
                <span class="n">super_type</span> <span class="o">=</span> <span class="n">parent_type_entry</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; - &quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">super_type</span> <span class="o">==</span> <span class="n">target_type</span><span class="p">:</span>
                    <span class="n">feedback_msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;[PASS]: claimed type matches target type definition.&quot;</span>
                    <span class="p">)</span>
                    <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">feedback_msg</span>
                <span class="n">current_type</span> <span class="o">=</span> <span class="n">super_type</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="n">feedback_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[ERROR]: claimed type `</span><span class="si">{</span><span class="n">claimed_type</span><span class="si">}</span><span class="s2">` does not match target `</span><span class="si">{</span><span class="n">target_type</span><span class="si">}</span><span class="s2">` or any of its possible sub-types.&quot;</span>
        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">feedback_msg</span></div>


<div class="viewcode-block" id="SyntaxValidator.validate_format_types">
<a class="viewcode-back" href="../../../l2p.html#l2p.utils.pddl_validator.SyntaxValidator.validate_format_types">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">validate_format_types</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">types</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if type variables contain `?` characters.</span>

<span class="sd">        Args:</span>
<span class="sd">            types (dict[str,str] | list[dict[str,str]]): types given from LLM output</span>

<span class="sd">        Returns:</span>
<span class="sd">            validation_info (tuple[bool,str]): validation info containing pass flag and error message</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">types</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;[PASS]: no types provided.&quot;</span>

        <span class="c1"># flatten types if it is in a hierarchy</span>
        <span class="n">types</span> <span class="o">=</span> <span class="n">format_types</span><span class="p">(</span><span class="n">types</span><span class="p">)</span>

        <span class="n">invalid_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t_name</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">types</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">t_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;?&quot;</span><span class="p">):</span>
                <span class="n">invalid_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; - </span><span class="si">{</span><span class="n">t_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">invalid_types</span><span class="p">:</span>
            <span class="n">invalid_types_str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invalid_types</span><span class="p">)</span>
            <span class="n">feedback_msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[ERROR]: There are type(s) with name(s) that start with character `?`. This is not allowed in PDDL.&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Remove `?` from the following type(s):</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">invalid_types_str</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Make sure each entry defines a type using the format:&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - &lt;type_name&gt;: &lt;description of type&gt;&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">For example:&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - car: a car that can drive&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">feedback_msg</span>

        <span class="n">feedback_msg</span> <span class="o">=</span> <span class="s2">&quot;[PASS]: all types are formatted correctly.&quot;</span>
        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">feedback_msg</span></div>


<div class="viewcode-block" id="SyntaxValidator.validate_cyclic_types">
<a class="viewcode-back" href="../../../l2p.html#l2p.utils.pddl_validator.SyntaxValidator.validate_cyclic_types">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">validate_cyclic_types</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">types</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the types given contain an invalid cyclic hierarchy.</span>

<span class="sd">        Args:</span>
<span class="sd">            types (dict[str,str] | list[dict[str,str]]): current types in domain</span>

<span class="sd">        Returns:</span>
<span class="sd">            validation_info (tuple[bool,str]): validation info containing pass flag and error message</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">visit_type</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">all_types</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Traverses the type hierarchy and check for cycles.&quot;&quot;&quot;</span>

            <span class="n">node_key</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>  <span class="c1"># get first type</span>

            <span class="c1"># if already visited this type, it indicates a cycle</span>
            <span class="k">if</span> <span class="n">node_key</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">cycle_path</span> <span class="o">=</span> <span class="s2">&quot; -&gt; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">path</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node_key</span><span class="p">)</span> <span class="p">:]</span> <span class="o">+</span> <span class="p">[</span><span class="n">node_key</span><span class="p">])</span>
                <span class="n">violated_type</span> <span class="o">=</span> <span class="n">node_key</span>  <span class="c1"># type that caused the cycle</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">cycle_path</span><span class="p">,</span> <span class="n">violated_type</span>

            <span class="c1"># mark the current type as visited in this traversal path</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node_key</span><span class="p">)</span>
            <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_key</span><span class="p">)</span>

            <span class="c1"># visit all children of the current node</span>
            <span class="k">if</span> <span class="s2">&quot;children&quot;</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">[</span><span class="s2">&quot;children&quot;</span><span class="p">]:</span>
                    <span class="n">result</span><span class="p">,</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">violated_type</span> <span class="o">=</span> <span class="n">visit_type</span><span class="p">(</span>
                        <span class="n">child</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">all_types</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">violated_type</span>

            <span class="c1"># also check if type appears elsewhere in the hierarchy with children</span>
            <span class="k">for</span> <span class="n">other_type</span> <span class="ow">in</span> <span class="n">all_types</span><span class="p">:</span>
                <span class="n">other_key</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">other_type</span><span class="p">))</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">other_key</span> <span class="o">==</span> <span class="n">node_key</span>
                    <span class="ow">and</span> <span class="s2">&quot;children&quot;</span> <span class="ow">in</span> <span class="n">other_type</span>
                    <span class="ow">and</span> <span class="n">other_type</span><span class="p">[</span><span class="s2">&quot;children&quot;</span><span class="p">]</span>
                <span class="p">):</span>
                    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">other_type</span><span class="p">[</span><span class="s2">&quot;children&quot;</span><span class="p">]:</span>
                        <span class="n">result</span><span class="p">,</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">violated_type</span> <span class="o">=</span> <span class="n">visit_type</span><span class="p">(</span>
                            <span class="n">child</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">all_types</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">violated_type</span>

            <span class="c1"># remove the type from the visited once its children are processed</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node_key</span><span class="p">)</span>
            <span class="n">path</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># if no types are provided, return invalid</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">types</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;[PASS]: no types provided.&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">types</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">types</span> <span class="o">=</span> <span class="p">[{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">}</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">types</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>

        <span class="c1"># iterate over all the top-level types</span>
        <span class="k">for</span> <span class="n">type_node</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># This will keep track of the current path</span>
            <span class="n">result</span><span class="p">,</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">violated_type</span> <span class="o">=</span> <span class="n">visit_type</span><span class="p">(</span><span class="n">type_node</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">types</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">feedback_msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[ERROR]: Circular dependency detected in the type hierarchy: </span><span class="si">{</span><span class="n">cycle</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">This means the type &#39;</span><span class="si">{</span><span class="n">violated_type</span><span class="si">}</span><span class="s2">&#39; indirectly inherits from itself through the chain:&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - Starts with: &#39;</span><span class="si">{</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - Leads back to: &#39;</span><span class="si">{</span><span class="n">violated_type</span><span class="si">}</span><span class="s2">&#39; via: </span><span class="si">{</span><span class="n">cycle</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">This creates an infinite loop in the type system where &#39;</span><span class="si">{</span><span class="n">violated_type</span><span class="si">}</span><span class="s2">&#39; cannot be properly defined because its parent eventually depends on itself&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Possible Solutions:&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">(1) Remove or modify one of the relationships in the cycle&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">(2) Consider flattening your hierarchy if circular references are needed&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">feedback_msg</span>

        <span class="n">feedback_msg</span> <span class="o">=</span> <span class="s2">&quot;[PASS]: Type hierarchy is valid.&quot;</span>
        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">feedback_msg</span></div>


<div class="viewcode-block" id="SyntaxValidator.validate_constant_types">
<a class="viewcode-back" href="../../../l2p.html#l2p.utils.pddl_validator.SyntaxValidator.validate_constant_types">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">validate_constant_types</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">constants</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">types</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if constant types are found in current :types.</span>

<span class="sd">        Args:</span>
<span class="sd">            constants (dict[str,str]): current :constants in domain</span>
<span class="sd">            types (dict[str,str] | list[dict[str,str]]): current types in domain</span>

<span class="sd">        Returns:</span>
<span class="sd">            validation_info (tuple[bool,str]): validation info containing pass flag and error message</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">constants</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;[PASS]: no constants provided.&quot;</span>

        <span class="n">types</span> <span class="o">=</span> <span class="n">format_types</span><span class="p">(</span><span class="n">types</span><span class="p">)</span>  <span class="c1"># flatten type hierarchy</span>

        <span class="k">if</span> <span class="n">types</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">const_name</span><span class="p">,</span> <span class="n">const_type</span> <span class="ow">in</span> <span class="n">constants</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">const_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">types</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">return</span> <span class="p">(</span>
                        <span class="kc">False</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;[ERROR]: constant `</span><span class="si">{</span><span class="n">const_name</span><span class="si">}</span><span class="s2">` contains type `</span><span class="si">{</span><span class="n">const_type</span><span class="si">}</span><span class="s2">` &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;that is not found in list of available types:</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pretty_print_dict</span><span class="p">(</span><span class="n">types</span><span class="p">)</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Make sure that constants only point to types that exist.&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;[PASS]: all constants are valid.&quot;</span></div>


    <span class="c1"># ---- PDDL FUNCTION CHECKS ----</span>

<div class="viewcode-block" id="SyntaxValidator.validate_format_functions">
<a class="viewcode-back" href="../../../l2p.html#l2p.utils.pddl_validator.SyntaxValidator.validate_format_functions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">validate_format_functions</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">functions</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Function</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">types</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check for any PDDL syntax found within functions, allowing untyped variables.</span>

<span class="sd">        Args:</span>
<span class="sd">            functions (list[Function]): list of functions in domain</span>
<span class="sd">            types (dict[str,str] | list[dict[str,str]]): current types in domain</span>

<span class="sd">        Returns:</span>
<span class="sd">            validation_info (tuple[bool,str]): validation info containing pass flag and error message</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">functions</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;[PASS]: no functions provided.&quot;</span>

        <span class="c1"># retrieve types</span>
        <span class="n">valid_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">types</span><span class="p">:</span>
            <span class="n">types</span> <span class="o">=</span> <span class="n">format_types</span><span class="p">(</span><span class="n">types</span><span class="p">)</span>
            <span class="n">valid_types</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">type_key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; - &quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">type_key</span> <span class="ow">in</span> <span class="n">types</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">valid_types</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">all_invalid_params</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">:</span>
            <span class="n">func_def</span> <span class="o">=</span> <span class="n">func</span><span class="p">[</span><span class="s2">&quot;clean&quot;</span><span class="p">]</span>
            <span class="n">func_def</span> <span class="o">=</span> <span class="n">func_def</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot; ()`&quot;</span><span class="p">)</span>  <span class="c1"># discard parentheses and similar</span>

            <span class="c1"># check if function name declared</span>
            <span class="k">if</span> <span class="n">func_def</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;?&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">func</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;?&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="kc">False</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;[ERROR]: Line `(</span><span class="si">{</span><span class="n">func_def</span><span class="si">}</span><span class="s2">)` does not contain a function name. Function names must not start with `?`. Revise function to include name. For example: `(battery-level ?c - car)` where `battery-level` is the function name.&quot;</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="n">split_function</span> <span class="o">=</span> <span class="n">func_def</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># discard function name</span>
            <span class="n">split_function</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">split_function</span> <span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">]</span>

            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_function</span><span class="p">):</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">split_function</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="c1"># variable name must start with `?`</span>
                <span class="k">if</span> <span class="s2">&quot;?&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                    <span class="c1"># catches random character declarations</span>
                    <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^[^\w\s]+$&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="ow">or</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span>
                        <span class="sa">r</span><span class="s2">&quot;^[^\w]&quot;</span><span class="p">,</span> <span class="n">f</span>
                    <span class="p">):</span>  <span class="c1"># all non-word or starts with symbol</span>
                        <span class="k">return</span> <span class="p">(</span>
                            <span class="kc">False</span><span class="p">,</span>
                            <span class="sa">f</span><span class="s2">&quot;[ERROR]: For PDDL, function `(</span><span class="si">{</span><span class="n">func_def</span><span class="si">}</span><span class="s2">)` appears to contain invalid or unexpected symbol `</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">`. This might be a parsing error or stray character. Make sure each parameter follows the format `?name - type`.&quot;</span><span class="p">,</span>
                        <span class="p">)</span>

                    <span class="n">raw_func</span> <span class="o">=</span> <span class="n">func</span><span class="p">[</span><span class="s2">&quot;raw&quot;</span><span class="p">]</span>

                    <span class="n">feedback_msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[ERROR]: For PDDL, there is a syntax issue in the function definition.&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">`</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">` appears where a variable is expected in function `</span><span class="si">{</span><span class="n">raw_func</span><span class="si">}</span><span class="s2">`.&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Possible causes:&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">(1) `</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">` is intended to be a variable but is missing the `?` prefix. All variables must start with `?`, like `?block`.&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">(2) `</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">` is actually a type, in which case it should appear after a `-` in a declaration like `?x - </span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">`.&quot;</span>
                    <span class="p">)</span>

                    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">feedback_msg</span>

                <span class="c1"># check if variable is followed by `- type` or nothing (untyped)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_function</span><span class="p">)</span> <span class="ow">and</span> <span class="n">split_function</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_function</span><span class="p">):</span>
                        <span class="k">return</span> <span class="p">(</span>
                            <span class="kc">False</span><span class="p">,</span>
                            <span class="sa">f</span><span class="s2">&quot;[ERROR]: For PDDL, there is a missing type after the `-` for parameter `</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">` in function `</span><span class="si">{</span><span class="n">func_def</span><span class="si">}</span><span class="s2">`. Make sure each parameter follows the format `?name - type`.&quot;</span><span class="p">,</span>
                        <span class="p">)</span>

                    <span class="n">param_obj_type</span> <span class="o">=</span> <span class="n">split_function</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">param_obj_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_types</span><span class="p">:</span>
                        <span class="n">all_invalid_params</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">param_obj_type</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">func_def</span><span class="p">))</span>

                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">3</span>  <span class="c1"># skip ?var - type</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># untyped variable</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># move to next token</span>

        <span class="k">if</span> <span class="n">all_invalid_params</span><span class="p">:</span>
            <span class="n">feedback_msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;[ERROR]: For PDDL, there are invalid object types in the functions:&quot;</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">param_obj_type</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">func_def</span> <span class="ow">in</span> <span class="n">all_invalid_params</span><span class="p">:</span>
                <span class="n">feedback_msg</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - `</span><span class="si">{</span><span class="n">param_obj_type</span><span class="si">}</span><span class="s2">` for the parameter `</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">` in the definition of the function `</span><span class="si">{</span><span class="n">func_def</span><span class="si">}</span><span class="s2">` &quot;</span>
                    <span class="o">+</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;not found in types: </span><span class="si">{</span><span class="n">valid_types</span><span class="si">}</span><span class="s2">.&quot;</span>
                        <span class="k">if</span> <span class="n">valid_types</span>
                        <span class="k">else</span> <span class="s2">&quot;contain types when no types are available.&quot;</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="n">feedback_msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Revise function parameters such that their types are assigned correctly. Otherwise leave variable untyped.&quot;</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">feedback_msg</span>

        <span class="n">feedback_msg</span> <span class="o">=</span> <span class="s2">&quot;[PASS]: All functions are formatted correctly.&quot;</span>
        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">feedback_msg</span></div>


    <span class="c1"># ---- PDDL PREDICATE CHECKS ----</span>

<div class="viewcode-block" id="SyntaxValidator.validate_types_predicates">
<a class="viewcode-back" href="../../../l2p.html#l2p.utils.pddl_validator.SyntaxValidator.validate_types_predicates">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">validate_types_predicates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">predicates</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Predicate</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">types</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if predicate name is found within any type definitions.</span>

<span class="sd">        Args:</span>
<span class="sd">            predicates (list[Predicate]): current predicates in domain / generated from LLM</span>
<span class="sd">            types (dict[str,str] | list[dict[str,str]]): current types in domain</span>

<span class="sd">        Returns:</span>
<span class="sd">            validation_info (tuple[bool,str]): validation info containing pass flag and error message</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">predicates</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;[PASS]: no predicates provided.&quot;</span>

        <span class="c1"># if types is None or empty, return true</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">types</span><span class="p">:</span>
            <span class="n">feedback_msg</span> <span class="o">=</span> <span class="s2">&quot;[PASS]: No types declared, all predicate names are unique.&quot;</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">feedback_msg</span>

        <span class="n">types</span> <span class="o">=</span> <span class="n">format_types</span><span class="p">(</span><span class="n">types</span><span class="p">)</span>

        <span class="n">invalid_predicates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">pred</span> <span class="ow">in</span> <span class="n">predicates</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">type_key</span> <span class="ow">in</span> <span class="n">types</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="c1"># extract the actual type name, disregarding hierarchical or descriptive parts</span>
                <span class="n">type_name</span> <span class="o">=</span> <span class="n">type_key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; - &quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

                <span class="c1"># check if the predicate name is exactly the same as the type name</span>
                <span class="k">if</span> <span class="n">pred</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">type_name</span><span class="p">:</span>
                    <span class="n">invalid_predicates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">invalid_predicates</span><span class="p">:</span>
            <span class="n">feedback_msg</span> <span class="o">=</span> <span class="s2">&quot;[ERROR]: The following predicate(s) have the same name(s) as existing object types:&quot;</span>
            <span class="k">for</span> <span class="n">pred_i</span><span class="p">,</span> <span class="n">pred</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">invalid_predicates</span><span class="p">):</span>
                <span class="n">feedback_msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">pred_i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">. `</span><span class="si">{</span><span class="n">pred</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">` from </span><span class="si">{</span><span class="n">pred</span><span class="p">[</span><span class="s1">&#39;clean&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">feedback_msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Rename these predicates that are unique from types: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">feedback_msg</span>

        <span class="n">feedback_msg</span> <span class="o">=</span> <span class="s2">&quot;[PASS]: All predicate names are unique to object type names&quot;</span>
        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">feedback_msg</span></div>


<div class="viewcode-block" id="SyntaxValidator.validate_duplicate_predicates">
<a class="viewcode-back" href="../../../l2p.html#l2p.utils.pddl_validator.SyntaxValidator.validate_duplicate_predicates">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">validate_duplicate_predicates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">curr_predicates</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Predicate</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">new_predicates</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Predicate</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if predicates have the same name but different parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">            curr_predicates (list[predicate]): current predicates in domain</span>
<span class="sd">            new_predicates (list[Predicate]): new predicates generated from LLM</span>

<span class="sd">        Returns:</span>
<span class="sd">            validation_info (tuple[bool,str]): validation info containing pass flag and error message</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">new_predicates</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;[PASS]: no new predicates were created.&quot;</span>

        <span class="k">if</span> <span class="n">curr_predicates</span><span class="p">:</span>
            <span class="n">curr_pred_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">pred</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]:</span> <span class="n">pred</span> <span class="k">for</span> <span class="n">pred</span> <span class="ow">in</span> <span class="n">curr_predicates</span><span class="p">}</span>

            <span class="n">duplicated_predicates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">new_pred</span> <span class="ow">in</span> <span class="n">new_predicates</span><span class="p">:</span>
                <span class="n">name_lower</span> <span class="o">=</span> <span class="n">new_pred</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">name_lower</span> <span class="ow">in</span> <span class="n">curr_pred_dict</span><span class="p">:</span>
                    <span class="n">curr</span> <span class="o">=</span> <span class="n">curr_pred_dict</span><span class="p">[</span><span class="n">name_lower</span><span class="p">]</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_pred</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">])</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span>
                        <span class="n">t1</span> <span class="o">!=</span> <span class="n">t2</span> <span class="k">for</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">curr</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">],</span> <span class="n">new_pred</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">])</span>
                    <span class="p">):</span>
                        <span class="n">duplicated_predicates</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">new_pred</span><span class="p">[</span><span class="s2">&quot;raw&quot;</span><span class="p">],</span> <span class="n">curr</span><span class="p">[</span><span class="s2">&quot;raw&quot;</span><span class="p">]))</span>

            <span class="k">if</span> <span class="n">duplicated_predicates</span><span class="p">:</span>
                <span class="n">feedback_msg</span> <span class="o">=</span> <span class="s2">&quot;[ERROR]: Duplicate predicate name(s) found with mismatched parameters.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">feedback_msg</span> <span class="o">+=</span> <span class="s2">&quot;You have defined predicates with the same name as existing ones but with different parameters, which is not allowed.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                <span class="n">feedback_msg</span> <span class="o">+=</span> <span class="s2">&quot;Conflicting predicate definitions:</span><span class="se">\n</span><span class="s2">&quot;</span>

                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">new_pred</span><span class="p">,</span> <span class="n">existing_pred</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">duplicated_predicates</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">feedback_msg</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">. New: </span><span class="si">{</span><span class="n">new_pred</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;;&#39;</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;   Conflicts with existing: </span><span class="si">{</span><span class="n">existing_pred</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;;&#39;</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

                <span class="n">feedback_msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">If you&#39;re trying to use the same concept, ensure the parameters match the existing definition exactly.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">feedback_msg</span> <span class="o">+=</span> <span class="s2">&quot;If this is a new concept, use a different predicate name to avoid confusion.</span><span class="se">\n</span><span class="s2">&quot;</span>

                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">feedback_msg</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="s2">&quot;[PASS]: All predicates are uniquely named and consistently defined.&quot;</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="SyntaxValidator.validate_overflow_predicates">
<a class="viewcode-back" href="../../../l2p.html#l2p.utils.pddl_validator.SyntaxValidator.validate_overflow_predicates">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">validate_overflow_predicates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">llm_response</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if LLM output contains too many predicates in precondition/effects (based on users assigned limit).</span>
<span class="sd">        This error is very rare, but can occur. Thus, it is omitted in core functions but is still available.</span>

<span class="sd">        Args:</span>
<span class="sd">            llm_response (str): raw LLM output</span>
<span class="sd">            limit (int): max number of states declared, default to 30</span>

<span class="sd">        Returns:</span>
<span class="sd">            validation_info (tuple[bool,str]): validation info containing pass flag and error message</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">spacer</span> <span class="o">=</span> <span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">50</span>

        <span class="k">assert</span> <span class="s2">&quot;Preconditions&quot;</span> <span class="ow">in</span> <span class="n">llm_response</span><span class="p">,</span> <span class="n">llm_response</span>
        <span class="n">precond_str</span> <span class="o">=</span> <span class="n">llm_response</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;Preconditions&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;```</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">precond_str</span> <span class="o">=</span> <span class="n">remove_comments</span><span class="p">(</span><span class="n">precond_str</span><span class="p">)</span>
        <span class="n">num_prec_pred</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">precond_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>  <span class="c1"># for outer brackets</span>
        <span class="k">if</span> <span class="n">num_prec_pred</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">:</span>
            <span class="n">feedback_msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[ERROR]: You seem to have generated an action model with an unusually long list of precondition predicates.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">spacer</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">precond_str</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">spacer</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Extracted predicates: </span><span class="si">{</span><span class="n">num_prec_pred</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Please include only the relevant preconditions and keep the action model concise or raise limit of predicates.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">feedback_msg</span>

        <span class="n">eff_str</span> <span class="o">=</span> <span class="n">llm_response</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;Effects&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;```</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">num_eff_pred</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eff_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>  <span class="c1"># for outer brackets</span>
        <span class="k">if</span> <span class="n">num_eff_pred</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">:</span>
            <span class="n">feedback_msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[ERROR]: You seem to have generated an action model with an unusually long list of effect predicates.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">spacer</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">eff_str</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">spacer</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Extracted predicates: </span><span class="si">{</span><span class="n">num_eff_pred</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Please include only the relevant effects and keep the action model concise or raise limit of predicates.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">feedback_msg</span>

        <span class="n">feedback_msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;[PASS]: predicate count satisfies limit of </span><span class="si">{</span><span class="n">limit</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Approximate predicates in preconditions: </span><span class="si">{</span><span class="n">num_prec_pred</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Approximate Predicates in effects: </span><span class="si">{</span><span class="n">num_eff_pred</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">feedback_msg</span></div>


<div class="viewcode-block" id="SyntaxValidator.validate_format_predicates">
<a class="viewcode-back" href="../../../l2p.html#l2p.utils.pddl_validator.SyntaxValidator.validate_format_predicates">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">validate_format_predicates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">predicates</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">types</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks for any PDDL syntactic errors found within predicates, allowing untyped variables.</span>

<span class="sd">        Args:</span>
<span class="sd">            predicates (list[Predicate]): current predicates in domain / generated from LLM</span>
<span class="sd">            types (dict[str,str] | list[dict[str,str]]): current types in domain</span>

<span class="sd">        Returns:</span>
<span class="sd">            validation_info (tuple[bool,str]): validation info containing pass flag and error message</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">predicates</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;[PASS: no predicates provided.&quot;</span>

        <span class="n">valid_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="c1"># flatten type hierarchy if exists</span>
        <span class="k">if</span> <span class="n">types</span><span class="p">:</span>
            <span class="n">types</span> <span class="o">=</span> <span class="n">format_types</span><span class="p">(</span><span class="n">types</span><span class="p">)</span>
            <span class="n">valid_types</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">type_key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; - &quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">type_key</span> <span class="ow">in</span> <span class="n">types</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">valid_types</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">all_invalid_params</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">pred</span> <span class="ow">in</span> <span class="n">predicates</span><span class="p">:</span>
            <span class="n">pred_def</span> <span class="o">=</span> <span class="n">pred</span><span class="p">[</span><span class="s2">&quot;clean&quot;</span><span class="p">]</span>
            <span class="n">pred_def</span> <span class="o">=</span> <span class="n">pred_def</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot; ()`&quot;</span><span class="p">)</span>  <span class="c1"># discard parentheses and similar</span>

            <span class="c1"># check if predicate name declared</span>
            <span class="k">if</span> <span class="n">pred_def</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;?&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">pred</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;?&quot;</span><span class="p">):</span>
                <span class="n">feedback_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[ERROR]: Line `(</span><span class="si">{</span><span class="n">pred_def</span><span class="si">}</span><span class="s2">)` does not contain a predicate name. Predicate names must not start with `?`. Revise predicate to include name. For example: `(stack ?b - block ?t - table)` where `stack` is the predicate name.&quot;</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">feedback_msg</span>

            <span class="n">split_predicate</span> <span class="o">=</span> <span class="n">pred_def</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># discard the predicate name</span>
            <span class="n">split_predicate</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">split_predicate</span> <span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">]</span>

            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_predicate</span><span class="p">):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">split_predicate</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="c1"># variable name must start with `?`</span>
                <span class="k">if</span> <span class="s2">&quot;?&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
                    <span class="c1"># catches random character declarations</span>
                    <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^[^\w\s]+$&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="ow">or</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span>
                        <span class="sa">r</span><span class="s2">&quot;^[^\w]&quot;</span><span class="p">,</span> <span class="n">p</span>
                    <span class="p">):</span>  <span class="c1"># all non-word or starts with symbol</span>
                        <span class="n">feedback_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[ERROR]: For PDDL, predicate `(</span><span class="si">{</span><span class="n">pred_def</span><span class="si">}</span><span class="s2">)` appears to contain invalid or unexpected symbol `</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">`. This might be a parsing error or stray character. Make sure each parameter follows the format `?name - type`.&quot;</span>
                        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">feedback_msg</span>

                    <span class="n">raw_pred</span> <span class="o">=</span> <span class="n">pred</span><span class="p">[</span><span class="s2">&quot;raw&quot;</span><span class="p">]</span>

                    <span class="n">feedback_msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[ERROR]: For PDDL, there is a syntax issue in the predicate definition.&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">`</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">` appears where a variable is expected in predicate `</span><span class="si">{</span><span class="n">raw_pred</span><span class="si">}</span><span class="s2">`.&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Possible causes:&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">(1) `</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">` is intended to be a variable but is missing the `?` prefix. All variables must start with `?`, like `?block`.&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">(2) `</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">` is actually a type, in which case it should appear after a `-` in a declaration like `?x - </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">`.&quot;</span>
                    <span class="p">)</span>

                    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">feedback_msg</span>

                <span class="c1"># check if variable is followed by `- type` or nothing (untyped)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_predicate</span><span class="p">)</span> <span class="ow">and</span> <span class="n">split_predicate</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_predicate</span><span class="p">):</span>
                        <span class="n">feedback_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[ERROR]: For PDDL, there is a missing type after the `-` for parameter `</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">` in new predicate `</span><span class="si">{</span><span class="n">pred_def</span><span class="si">}</span><span class="s2">`. Make sure each parameter follows the format `?name - type`.&quot;</span>
                        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">feedback_msg</span>

                    <span class="n">param_obj_type</span> <span class="o">=</span> <span class="n">split_predicate</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">param_obj_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_types</span><span class="p">:</span>
                        <span class="n">all_invalid_params</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">param_obj_type</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">pred_def</span><span class="p">))</span>

                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">3</span>  <span class="c1"># skip ?var - type</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># untyped variable (just ?var)</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># move to next token</span>

        <span class="k">if</span> <span class="n">all_invalid_params</span><span class="p">:</span>
            <span class="n">feedback_msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;[ERROR]: For PDDL, there are invalid object types in the predicates:&quot;</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">param_obj_type</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">pred_def</span> <span class="ow">in</span> <span class="n">all_invalid_params</span><span class="p">:</span>
                <span class="n">feedback_msg</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - `</span><span class="si">{</span><span class="n">param_obj_type</span><span class="si">}</span><span class="s2">` for the parameter `</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">` in the definition of the predicate `</span><span class="si">{</span><span class="n">pred_def</span><span class="si">}</span><span class="s2">` &quot;</span>
                    <span class="o">+</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;not found in types: </span><span class="si">{</span><span class="n">valid_types</span><span class="si">}</span><span class="s2">.&quot;</span>
                        <span class="k">if</span> <span class="n">valid_types</span>
                        <span class="k">else</span> <span class="s2">&quot;contain types when no types are available.&quot;</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="n">feedback_msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Revise predicate parameters such that their types are assigned correctly. Otherwise leave variable untyped.&quot;</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">feedback_msg</span>

        <span class="n">feedback_msg</span> <span class="o">=</span> <span class="s2">&quot;[PASS]: All predicates are formatted correctly.&quot;</span>
        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">feedback_msg</span></div>


    <span class="c1"># ---- PDDL ACTION CHECKS ----</span>

<div class="viewcode-block" id="SyntaxValidator.validate_pddl_action">
<a class="viewcode-back" href="../../../l2p.html#l2p.utils.pddl_validator.SyntaxValidator.validate_pddl_action">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">validate_pddl_action</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pddl</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">predicates</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Predicate</span><span class="p">],</span>
        <span class="n">action_params</span><span class="p">:</span> <span class="n">OrderedDict</span><span class="p">,</span>
        <span class="n">functions</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Function</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">types</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">part</span><span class="o">=</span><span class="s2">&quot;preconditions&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validates predicates and fluent expression in nested PDDL list format. There are many specific</span>
<span class="sd">        checks in this validation function. This is where LLMs encounter the most syntax errors.</span>

<span class="sd">        Performs three main kinds of checks:</span>
<span class="sd">            (i) if predicate / functions statements are misused or does not exist</span>
<span class="sd">            (ii) if state parameters align with original definition parameters</span>
<span class="sd">            (iii) if arguments are being passed correctly (i.e. conditional-effects)</span>

<span class="sd">        Args:</span>
<span class="sd">            pddl (str): part of PDDL section from LLM</span>
<span class="sd">            predicates (list[Predicate]): current predicates in domain / generated from LLM</span>
<span class="sd">            action_params (OrderedDict): PDDL parameters of current action</span>
<span class="sd">            functions (list[Function]): list of current functions in domain</span>
<span class="sd">            types (dict[str,str] | list[dict[str,str]]): current types in domain</span>
<span class="sd">            part (str): section of the PDDL to focus on</span>

<span class="sd">        Returns:</span>
<span class="sd">            validation_info (tuple[bool,str]): validation info containing pass flag and error message</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pddl</span> <span class="o">=</span> <span class="n">parse_pddl</span><span class="p">(</span><span class="n">pddl</span><span class="p">)</span>  <span class="c1"># parse into nested list</span>

        <span class="c1"># retrieve dict comprehension for each predicate/function</span>
        <span class="n">pred_index</span> <span class="o">=</span> <span class="p">{</span><span class="n">pred</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]:</span> <span class="n">pred</span> <span class="k">for</span> <span class="n">pred</span> <span class="ow">in</span> <span class="n">predicates</span><span class="p">}</span>
        <span class="n">func_index</span> <span class="o">=</span> <span class="p">{</span><span class="n">func</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]:</span> <span class="n">func</span> <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">}</span> <span class="k">if</span> <span class="n">functions</span> <span class="k">else</span> <span class="p">{}</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_ordinal_suffix</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Helper function that appends parameter index to string&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">ORDINAL_SUFFIXES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;th&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">100</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>
                <span class="k">else</span> <span class="s2">&quot;th&quot;</span>
            <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">is_value</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Helper function that checks if a string is numeric&quot;&quot;&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">split_var_type_pairs</span><span class="p">(</span><span class="n">raw_list</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Helper function that for parsing typed variable declarations in PDDL-like syntax.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">raw_list</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>
            <span class="n">tokens</span> <span class="o">=</span> <span class="n">raw_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">result</span><span class="p">,</span> <span class="n">current_vars</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">token</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">current_vars</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">tokens</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
                    <span class="n">var_type</span> <span class="o">=</span> <span class="n">token</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="n">var_type</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">current_vars</span><span class="p">)</span>
                    <span class="n">current_vars</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">current_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">current_vars</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">validate_term</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="n">scoped_params</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Recursive function that validates a term which may be a function or value.&quot;&quot;&quot;</span>

            <span class="c1"># if nested expression</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="c1"># (1) if term is a numeric operator</span>
                <span class="n">head_parts</span> <span class="o">=</span> <span class="n">term</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">head_parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">head</span> <span class="ow">in</span> <span class="n">NUMERIC_OPERATORS</span><span class="p">:</span>
                    <span class="n">terms_</span> <span class="o">=</span> <span class="n">term</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">term</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms_</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="k">return</span> <span class="p">(</span>
                            <span class="kc">False</span><span class="p">,</span>
                            <span class="sa">f</span><span class="s2">&quot;[ERROR]: Numeric operator `</span><span class="si">{</span><span class="n">head</span><span class="si">}</span><span class="s2">` requires two arguments: </span><span class="si">{</span><span class="n">format_pddl_expr</span><span class="p">(</span><span class="n">terms_</span><span class="p">)</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;Parsed line: </span><span class="si">{</span><span class="n">format_pddl_expr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;Make sure that only fluents are used and not variables.&quot;</span><span class="p">,</span>
                        <span class="p">)</span>

                    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">term</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                        <span class="n">valid</span><span class="p">,</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">validate_term</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">scoped_params</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
                            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">msg</span>
                    <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;[PASS]&quot;</span>

                <span class="c1"># (2) if term is a function or nested expression</span>
                <span class="n">func_</span> <span class="o">=</span> <span class="n">term</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
                <span class="n">func_name</span> <span class="o">=</span> <span class="n">func_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">func_args</span> <span class="o">=</span> <span class="n">func_</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

                <span class="c1"># checks if function name in pddl not found in :function list</span>
                <span class="k">if</span> <span class="n">func_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">func_index</span><span class="p">:</span>

                    <span class="c1"># extra catch - could be predicate but used as a function!</span>
                    <span class="k">if</span> <span class="n">func_name</span> <span class="ow">in</span> <span class="n">pred_index</span><span class="p">:</span>
                        <span class="k">return</span> <span class="p">(</span>
                            <span class="kc">False</span><span class="p">,</span>
                            <span class="sa">f</span><span class="s2">&quot;[ERROR]: `</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">` is a predicate, not a function. Predicates cannot be used to return numeric values but instead as standalone conditions.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;Parsed line: </span><span class="si">{</span><span class="n">format_pddl_expr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;Predicates can only be used within a boolean contextthat is, they must appear inside logical expressions like `and`, `or`, `not`, `when`, or standalone conditions in PDDL actions.&quot;</span><span class="p">,</span>
                        <span class="p">)</span>

                    <span class="n">available_funcs</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="p">(</span>
                            <span class="s2">&quot; - &quot;</span>
                            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                                <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;desc&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">]</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">functions</span>
                        <span class="k">else</span> <span class="s2">&quot;No functions available.&quot;</span>
                    <span class="p">)</span>

                    <span class="n">available_funcs</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;List of available function(s) are:</span><span class="se">\n</span><span class="s2"> - &quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;raw&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">functions</span>
                        <span class="k">else</span> <span class="s2">&quot;Numeric fluents cannot be used because no functions are declared in the :functions section of the domain.&quot;</span>
                    <span class="p">)</span>
                    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[ERROR]: Undeclared function `(</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">)` found in </span><span class="si">{</span><span class="n">part</span><span class="si">}</span><span class="s2">.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">available_funcs</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Parsed line: </span><span class="si">{</span><span class="n">format_pddl_expr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># retrieve target function arguments</span>
                <span class="n">target_func</span> <span class="o">=</span> <span class="n">func_index</span><span class="p">[</span><span class="n">func_name</span><span class="p">]</span>
                <span class="n">expected_args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">target_func</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">expected_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">target_func</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

                <span class="c1"># checks if function arguments align with :function list</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">func_args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">expected_args</span><span class="p">):</span>
                    <span class="k">return</span> <span class="p">(</span>
                        <span class="kc">False</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;[ERROR]: Function `</span><span class="si">{</span><span class="n">target_func</span><span class="p">[</span><span class="s1">&#39;clean&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">` expects </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">expected_args</span><span class="p">)</span><span class="si">}</span><span class="s2"> variable parameter(s), &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;but found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">term</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">part</span><span class="si">}</span><span class="s2">.</span><span class="se">\n\n</span><span class="s2">Parsed line: (</span><span class="si">{</span><span class="n">format_pddl_expr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="c1"># recursively checks if function argument is nested</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">func_args</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">valid</span><span class="p">,</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">validate_term</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">scoped_params</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
                            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">msg</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># leaf of function call</span>
                        <span class="n">expected_type</span> <span class="o">=</span> <span class="n">expected_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">actual_type</span> <span class="o">=</span> <span class="n">scoped_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">expected_type</span> <span class="ow">and</span> <span class="n">actual_type</span><span class="p">:</span>

                            <span class="c1"># checks if :types exists</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">types</span><span class="p">:</span>
                                <span class="k">return</span> <span class="p">(</span>
                                    <span class="kc">False</span><span class="p">,</span>
                                    <span class="sa">f</span><span class="s2">&quot;[ERROR]: Types declared but type dictionary is empty.&quot;</span><span class="p">,</span>
                                <span class="p">)</span>

                            <span class="c1"># validates if variable type aligns with target :type</span>
                            <span class="n">flag</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_type</span><span class="p">(</span>
                                <span class="n">expected_type</span><span class="p">,</span> <span class="n">actual_type</span><span class="p">,</span> <span class="n">types</span>
                            <span class="p">)</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">:</span>
                                <span class="n">param_number</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                                <span class="n">suffix</span> <span class="o">=</span> <span class="n">get_ordinal_suffix</span><span class="p">(</span><span class="n">param_number</span><span class="p">)</span>
                                <span class="k">return</span> <span class="p">(</span>
                                    <span class="kc">False</span><span class="p">,</span>
                                    <span class="sa">f</span><span class="s2">&quot;[ERROR]: The </span><span class="si">{</span><span class="n">param_number</span><span class="si">}{</span><span class="n">suffix</span><span class="si">}</span><span class="s2"> parameter of `</span><span class="si">{</span><span class="n">target_func</span><span class="p">[</span><span class="s1">&#39;clean&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">` &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;should be of type `</span><span class="si">{</span><span class="n">expected_type</span><span class="si">}</span><span class="s2">`, but `</span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2">` is `</span><span class="si">{</span><span class="n">actual_type</span><span class="si">}</span><span class="s2">`</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;Parsed line: </span><span class="si">{</span><span class="n">format_pddl_expr</span><span class="p">(</span><span class="n">term</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;Found in: </span><span class="si">{</span><span class="n">format_pddl_expr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                <span class="p">)</span>

                        <span class="c1"># checks if variable is in the scope of available variables</span>
                        <span class="k">if</span> <span class="n">arg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">scoped_params</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_value</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
                            <span class="k">return</span> <span class="p">(</span>
                                <span class="kc">False</span><span class="p">,</span>
                                <span class="sa">f</span><span class="s2">&quot;[ERROR]: Argument `</span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2">` not found in scope for function `</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">`.</span><span class="se">\n</span><span class="s2">Scope: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">scoped_params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;Parsed line: </span><span class="si">{</span><span class="n">format_pddl_expr</span><span class="p">(</span><span class="n">term</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;Found in: </span><span class="si">{</span><span class="n">format_pddl_expr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;Make sure the function uses the correct variables from its scope. Otherwise, you may need to add a new variable to the parameters section.&quot;</span><span class="p">,</span>
                            <span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;[PASS]&quot;</span>

            <span class="c1"># if not nested expression, it is a variable or constant</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">term</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">scoped_params</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_value</span><span class="p">(</span><span class="n">term</span><span class="p">):</span>
                    <span class="k">return</span> <span class="p">(</span>
                        <span class="kc">False</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;[ERROR]: Variable `</span><span class="si">{</span><span class="n">term</span><span class="si">}</span><span class="s2">` not in scope: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">scoped_params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;[PASS]&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">scoped_params</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Recursive function that goes through nested list.&quot;&quot;&quot;</span>

            <span class="c1"># if reached end node with no errors, return true</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;[PASS]&quot;</span>

            <span class="n">keyword</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># extract keyword from node</span>

            <span class="c1"># (1) if keyword is a logical connective (and, not, or)</span>
            <span class="k">if</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="n">LOGICAL_CONNECTIVES</span><span class="p">:</span>

                <span class="c1"># recursively branch child nodes</span>
                <span class="n">children</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="n">keyword</span> <span class="o">!=</span> <span class="s2">&quot;not&quot;</span> <span class="k">else</span> <span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                    <span class="n">valid</span><span class="p">,</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">scoped_params</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">msg</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;[PASS]&quot;</span>

            <span class="c1"># (2) if keyword is a quantifier (forall, exists)</span>
            <span class="k">if</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="n">QUANTIFIERS</span><span class="p">:</span>

                <span class="c1"># validates correct arguments provided into quantifier</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span>
                        <span class="kc">False</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;[ERROR]: malformed usage of `</span><span class="si">{</span><span class="n">keyword</span><span class="si">}</span><span class="s2">` statement. There should be 3 main arguments, but </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2"> was given.&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Make sure to adhere to valid PDDL syntax. For example: `(</span><span class="si">{</span><span class="n">keyword</span><span class="si">}</span><span class="s2"> (&lt;variable_list&gt;) (&lt;logical_expression(s)&gt;))`</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Parsed line: </span><span class="si">{</span><span class="n">format_pddl_expr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Possible solutions:</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;  (1) Always wrap the list of variables with their types in parentheses, even for a single variable.</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;  (2) The second argument of </span><span class="si">{</span><span class="n">keyword</span><span class="si">}</span><span class="s2"> should be a valid condition, or a use of `and/or` expression to wrap multiple conditions.&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="c1"># parse quantified variable declarations</span>
                <span class="n">param_spec</span> <span class="o">=</span> <span class="n">split_var_type_pairs</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">body</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">new_scope</span> <span class="o">=</span> <span class="n">scoped_params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">param_spec</span><span class="p">:</span>
                    <span class="n">parts</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
                    <span class="n">var</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">var_type</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>

                    <span class="c1"># validate if type exists in :types</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">var_type</span> <span class="ow">or</span> <span class="n">var_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;[ERROR]: Unknown type declared `</span><span class="si">{</span><span class="n">var_type</span><span class="si">}</span><span class="s2">` for `</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">` in quantifier `</span><span class="si">{</span><span class="n">keyword</span><span class="si">}</span><span class="s2">`</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;Parsed line: </span><span class="si">{</span><span class="n">format_pddl_expr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;Make sure that the PDDL actions do not contain any type declarations. For example: `(drive ?c)` is correct, but `(drive ?c - car)` is invalid&quot;</span>
                        <span class="p">)</span>
                    <span class="n">new_scope</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">var_type</span>  <span class="c1"># update variable scope environment</span>
                <span class="k">return</span> <span class="n">traverse</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">new_scope</span><span class="p">)</span>

            <span class="c1"># (3) if keyword is a conditional effect (when)</span>
            <span class="k">if</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="n">CONDITIONAL_EFFECTS</span><span class="p">:</span>
                <span class="c1"># ensures conditional effects only found in :effects</span>
                <span class="k">if</span> <span class="n">part</span> <span class="o">!=</span> <span class="s2">&quot;effects&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span>
                        <span class="kc">False</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;[ERROR]: `</span><span class="si">{</span><span class="n">keyword</span><span class="si">}</span><span class="s2">` is only allowed in the :effects section, but found in </span><span class="si">{</span><span class="n">part</span><span class="si">}</span><span class="s2">.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Parsed line: </span><span class="si">{</span><span class="n">format_pddl_expr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span>
                        <span class="kc">False</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;[ERROR]: malformed usage of `</span><span class="si">{</span><span class="n">keyword</span><span class="si">}</span><span class="s2">` statement. There should be 3 main arguments, but </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2"> was given.&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Make sure to adhere to valid PDDL syntax. For example: `(</span><span class="si">{</span><span class="n">keyword</span><span class="si">}</span><span class="s2"> (&lt;condition(s)&gt;) (&lt;effect(s)&gt;))`</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Parsed line: </span><span class="si">{</span><span class="n">format_pddl_expr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Possible solutions:</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;  (1) `</span><span class="si">{</span><span class="n">keyword</span><span class="si">}</span><span class="s2">` must have two arguments: `(when &lt;condition&gt; &lt;effect&gt;)` where both condition and effect must be wrapped in parentheses.</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;  (2) If there are multiple conditions or effects, they must use a logical connective like `and` expression to wrap arguments.&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="n">valid</span><span class="p">,</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">scoped_params</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Invalid condition in &#39;when&#39;: </span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">valid</span><span class="p">,</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">scoped_params</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Invalid effect in &#39;when&#39;: </span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;[PASS]&quot;</span>

            <span class="c1"># (4) if keyword is a numeric-fluent operator</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">keyword</span>
                <span class="ow">in</span> <span class="n">COMPARISON_OPERATORS</span> <span class="o">|</span> <span class="n">NUMERIC_OPERATORS</span> <span class="o">|</span> <span class="n">ASSIGNMENT_OPERATORS</span>
            <span class="p">):</span>
                <span class="c1"># ensures assignment operators only found in :effects</span>
                <span class="k">if</span> <span class="n">part</span> <span class="o">!=</span> <span class="s2">&quot;effects&quot;</span> <span class="ow">and</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="n">ASSIGNMENT_OPERATORS</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span>
                        <span class="kc">False</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;[ERROR]: `</span><span class="si">{</span><span class="n">keyword</span><span class="si">}</span><span class="s2">` is only allowed in the :effects section, but found in </span><span class="si">{</span><span class="n">part</span><span class="si">}</span><span class="s2">.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Parsed line: </span><span class="si">{</span><span class="n">format_pddl_expr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="c1"># check if equality is doing object comparison</span>
                <span class="k">if</span> <span class="n">keyword</span> <span class="o">==</span> <span class="s2">&quot;=&quot;</span><span class="p">:</span>
                    <span class="n">parts</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">arg_1</span><span class="p">,</span> <span class="n">arg_2</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

                        <span class="k">if</span> <span class="n">arg_1</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;?&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arg_2</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;?&quot;</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">(</span><span class="n">arg_1</span><span class="p">,</span> <span class="n">arg_2</span><span class="p">):</span>
                                <span class="k">if</span> <span class="n">arg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">scoped_params</span><span class="p">:</span>
                                    <span class="k">return</span> <span class="p">(</span>
                                        <span class="kc">False</span><span class="p">,</span>
                                        <span class="sa">f</span><span class="s2">&quot;[ERROR]: variable `</span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2">` not found in scope of the </span><span class="si">{</span><span class="n">part</span><span class="si">}</span><span class="s2"> section. &quot;</span>
                                        <span class="sa">f</span><span class="s2">&quot;Available variables in scope: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">scoped_params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                                        <span class="sa">f</span><span class="s2">&quot;Parsed line: </span><span class="si">{</span><span class="n">format_pddl_expr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                                        <span class="sa">f</span><span class="s2">&quot;Possible solutions:</span><span class="se">\n</span><span class="s2">&quot;</span>
                                        <span class="sa">f</span><span class="s2">&quot;  (1) Revise line to only use variables in scope.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                        <span class="sa">f</span><span class="s2">&quot;  (2) If necessary, create new variables in the parameters or consider using quantifiers.&quot;</span><span class="p">,</span>
                                    <span class="p">)</span>

                            <span class="c1"># check if the arguments are the same type</span>
                            <span class="k">if</span> <span class="n">scoped_params</span><span class="p">[</span><span class="n">arg_1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">scoped_params</span><span class="p">[</span><span class="n">arg_2</span><span class="p">]:</span>
                                <span class="k">return</span> <span class="p">(</span>
                                    <span class="kc">False</span><span class="p">,</span>
                                    <span class="sa">f</span><span class="s2">&quot;[ERROR]: invalid object equality usage in the </span><span class="si">{</span><span class="n">part</span><span class="si">}</span><span class="s2"> section.</span><span class="se">\n</span><span class="s2">Variable `</span><span class="si">{</span><span class="n">arg_1</span><span class="si">}</span><span class="s2">` points to type `</span><span class="si">{</span><span class="n">scoped_params</span><span class="p">[</span><span class="n">arg_1</span><span class="p">]</span><span class="si">}</span><span class="s2">`. However, variable `</span><span class="si">{</span><span class="n">arg_2</span><span class="si">}</span><span class="s2">` points to type `</span><span class="si">{</span><span class="n">scoped_params</span><span class="p">[</span><span class="n">arg_2</span><span class="p">]</span><span class="si">}</span><span class="s2">`</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;Parsed line: </span><span class="si">{</span><span class="n">format_pddl_expr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;Make sure that when using object equality, the variables share the same types.&quot;</span><span class="p">,</span>
                                <span class="p">)</span>

                            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;[PASS]&quot;</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span>
                        <span class="kc">False</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;[ERROR]: `</span><span class="si">{</span><span class="n">keyword</span><span class="si">}</span><span class="s2">` operator requires exactly two arguments.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Parsed line: </span><span class="si">{</span><span class="n">format_pddl_expr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Verify that the expression has exactly two arguments in the form: (</span><span class="si">{</span><span class="n">keyword</span><span class="si">}</span><span class="s2"> (&lt;arg1&gt;) (&lt;arg2&gt;)),</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;where both &lt;arg1&gt; and &lt;arg2&gt; can be numeric constants (e.g., 5, 3.14, -2)</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;or numeric function expressions (e.g., (total-cost), (fuel-level ?v)).&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="c1"># traverse terms of operator statement</span>
                    <span class="n">valid</span><span class="p">,</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">validate_term</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="n">scoped_params</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">msg</span>

                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;[PASS]&quot;</span>

            <span class="c1"># (5) if keyword is a predicate</span>
            <span class="n">pred_name</span> <span class="o">=</span> <span class="n">keyword</span>
            <span class="n">pred_args</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>

            <span class="c1"># validate if predicate is found in :predicates</span>
            <span class="k">if</span> <span class="n">pred_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pred_index</span><span class="p">:</span>

                <span class="c1"># extra catch - could be function but used as a predicate!</span>
                <span class="k">if</span> <span class="n">pred_name</span> <span class="ow">in</span> <span class="n">func_index</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span>
                        <span class="kc">False</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;[ERROR]: `</span><span class="si">{</span><span class="n">pred_name</span><span class="si">}</span><span class="s2">` is a function, not a predicate. Functions return numeric values and cannot be used as standalone conditions.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Parsed line: </span><span class="si">{</span><span class="n">format_pddl_expr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Functions can only be used within a numeric context such as comparison (e.g., `(= (&lt;function_name&gt; &lt;?var&gt;) &lt;numeric_expression&gt;)`)&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="n">available_preds</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span>
                        <span class="s2">&quot; - &quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                            <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;desc&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">predicates</span><span class="p">]</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">predicates</span>
                    <span class="k">else</span> <span class="s2">&quot;No predicates available.&quot;</span>
                <span class="p">)</span>

                <span class="k">return</span> <span class="p">(</span>
                    <span class="kc">False</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;[ERROR]: Undeclared predicate `(</span><span class="si">{</span><span class="n">pred_name</span><span class="si">}</span><span class="s2">)` found in </span><span class="si">{</span><span class="n">part</span><span class="si">}</span><span class="s2">.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Available predicates:</span><span class="se">\n</span><span class="si">{</span><span class="n">available_preds</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Parsed line: </span><span class="si">{</span><span class="n">format_pddl_expr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># retrieve target predicate arguments</span>
            <span class="n">target_pred</span> <span class="o">=</span> <span class="n">pred_index</span><span class="p">[</span><span class="n">pred_name</span><span class="p">]</span>
            <span class="n">expected_args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">target_pred</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">expected_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">target_pred</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

            <span class="c1"># checks if predicate arguments align with :predicates list</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pred_args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">expected_args</span><span class="p">):</span>

                <span class="k">return</span> <span class="p">(</span>
                    <span class="kc">False</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;[ERROR]: Predicate `</span><span class="si">{</span><span class="n">target_pred</span><span class="p">[</span><span class="s1">&#39;clean&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">` expects </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">expected_args</span><span class="p">)</span><span class="si">}</span><span class="s2"> parameters, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;but found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">pred_args</span><span class="p">)</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">part</span><span class="si">}</span><span class="s2">.</span><span class="se">\n\n</span><span class="s2">Parsed line: </span><span class="si">{</span><span class="n">format_pddl_expr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Make sure that only variables (i.e. `?var`) is being passed through a predicate argument and not its type. For example: `(pred_name ?var)` is correct; `(pred_name ?var - object)` is incorrect.&quot;</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pred_args</span><span class="p">):</span>
                <span class="c1"># recursively checks if predicate argument is nested</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">valid</span><span class="p">,</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">validate_term</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">scoped_params</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">msg</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># checks if parameter variables are found in current scope</span>
                    <span class="k">if</span> <span class="n">arg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">scoped_params</span><span class="p">:</span>
                        <span class="k">return</span> <span class="p">(</span>
                            <span class="kc">False</span><span class="p">,</span>
                            <span class="sa">f</span><span class="s2">&quot;[ERROR]: Variable `</span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2">` not found in scope for predicate `</span><span class="si">{</span><span class="n">pred_name</span><span class="si">}</span><span class="s2">`.</span><span class="se">\n\n</span><span class="s2">Available variables in scope: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">scoped_params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;Parsed line: </span><span class="si">{</span><span class="n">format_pddl_expr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;Make sure the predicate uses the correct variables from its scope. Otherwise, you may need to add a new variable to the parameters section.&quot;</span><span class="p">,</span>
                        <span class="p">)</span>

                    <span class="c1"># check if type of variable matches predicate type</span>
                    <span class="n">expected_type</span> <span class="o">=</span> <span class="n">expected_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">actual_type</span> <span class="o">=</span> <span class="n">scoped_params</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">expected_type</span> <span class="ow">and</span> <span class="n">actual_type</span><span class="p">:</span>

                        <span class="c1"># if types is empty and it calls a type</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">types</span><span class="p">:</span>
                            <span class="k">return</span> <span class="p">(</span>
                                <span class="kc">False</span><span class="p">,</span>
                                <span class="sa">f</span><span class="s2">&quot;[ERROR]: Types declared in predicate, but types list is empty.&quot;</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="n">flag</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_type</span><span class="p">(</span><span class="n">expected_type</span><span class="p">,</span> <span class="n">actual_type</span><span class="p">,</span> <span class="n">types</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">:</span>
                            <span class="n">suffix</span> <span class="o">=</span> <span class="n">get_ordinal_suffix</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                            <span class="k">return</span> <span class="p">(</span>
                                <span class="kc">False</span><span class="p">,</span>
                                <span class="sa">f</span><span class="s2">&quot;[ERROR]: The </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}{</span><span class="n">suffix</span><span class="si">}</span><span class="s2"> parameter of `</span><span class="si">{</span><span class="n">target_pred</span><span class="p">[</span><span class="s1">&#39;clean&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">` &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;should be of type `</span><span class="si">{</span><span class="n">expected_type</span><span class="si">}</span><span class="s2">`, but `</span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2">` is `</span><span class="si">{</span><span class="n">actual_type</span><span class="si">}</span><span class="s2">`</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;Parsed line: </span><span class="si">{</span><span class="n">format_pddl_expr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                            <span class="p">)</span>

            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;[PASS]&quot;</span>

        <span class="c1"># resurively invoked function to branch nested list</span>
        <span class="k">return</span> <span class="n">traverse</span><span class="p">(</span><span class="n">pddl</span><span class="p">,</span> <span class="n">scoped_params</span><span class="o">=</span><span class="n">action_params</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>


<div class="viewcode-block" id="SyntaxValidator.validate_params">
<a class="viewcode-back" href="../../../l2p.html#l2p.utils.pddl_validator.SyntaxValidator.validate_params">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">validate_params</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">parameters</span><span class="p">:</span> <span class="n">OrderedDict</span><span class="p">,</span>
        <span class="n">types</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether a PDDL action parameter is correctly</span>
<span class="sd">        formatted and type declaration assigned correctly.</span>

<span class="sd">        Args:</span>
<span class="sd">            parameters (OrderedDict): parameters of an action</span>
<span class="sd">            types (dict[str,str] | list[dict[str,str]]): current types in domain</span>

<span class="sd">        Returns:</span>
<span class="sd">            validation_info (tuple[bool,str]): validation info containing pass flag and error message</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check if parameter names (i.e. ?a) contains &#39;?&#39;</span>
        <span class="n">invalid_param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">param_type</span> <span class="ow">in</span> <span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">param_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;?&quot;</span><span class="p">):</span>
                <span class="n">invalid_param_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="n">param_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">invalid_param_names</span><span class="p">:</span>
            <span class="n">feedback_msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[ERROR]: Character `?` is not found in parameter(s) `</span><span class="si">{</span><span class="n">invalid_param_names</span><span class="si">}</span><span class="s2">` &quot;</span>
                <span class="s2">&quot;Please insert `?` in front of the parameter names (i.e. ?boat - vehicle)&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">feedback_msg</span>

        <span class="c1"># catch if dash is used but type is missing</span>
        <span class="n">missing_type_after_dash</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">param_type</span> <span class="ow">in</span> <span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;-&quot;</span> <span class="ow">in</span> <span class="n">param_name</span><span class="p">:</span>
                <span class="n">parts</span> <span class="o">=</span> <span class="n">param_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                    <span class="n">missing_type_after_dash</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">missing_type_after_dash</span><span class="p">:</span>
            <span class="n">feedback_msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[ERROR]: One or more parameters use `-` but do not specify a type: </span><span class="si">{</span><span class="n">missing_type_after_dash</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;Each parameter using `-` must be followed by a valid type (e.g., `?c - car`).&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">feedback_msg</span>

        <span class="n">types</span> <span class="o">=</span> <span class="n">format_types</span><span class="p">(</span><span class="n">types</span><span class="p">)</span>
        <span class="c1"># if no types are defined, check if parameters contain types</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">types</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">param_type</span> <span class="ow">in</span> <span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">param_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">param_type</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                    <span class="n">feedback_msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[ERROR]: The parameter `</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">` has an object type `</span><span class="si">{</span><span class="n">param_type</span><span class="si">}</span><span class="s2">` &quot;</span>
                        <span class="s2">&quot;while no types are defined. Please remove the object type from this parameter.&quot;</span>
                    <span class="p">)</span>
                    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">feedback_msg</span>

            <span class="c1"># if all parameter names do not contain a type</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;[PASS]: All parameters are valid.&quot;</span>

        <span class="c1"># otherwise check that parameter types are valid in the given types</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">param_type</span> <span class="ow">in</span> <span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">param_type</span> <span class="ow">in</span> <span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="n">feedback_msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[ERROR]: There is an invalid object type `</span><span class="si">{</span><span class="n">param_type</span><span class="si">}</span><span class="s2">` for the parameter `</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">` not found in the types </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2"> found in the action parameters section. Parameter types should align with the provided types, otherwise just leave parameter untyped.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Make sure each line defines a parameter using the format: &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;`?&lt;parameter_name&gt; - &lt;type_name&gt;: &lt;description of parameter&gt;`</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;For example:</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;`?c - car: a car that can drive`</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;or `?c: a car that can drive` if not using a type&quot;</span>
                    <span class="p">)</span>
                    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">feedback_msg</span>

            <span class="n">feedback_msg</span> <span class="o">=</span> <span class="s2">&quot;[PASS]: All parameter types found in object types.&quot;</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">feedback_msg</span></div>


<div class="viewcode-block" id="SyntaxValidator.validate_usage_action">
<a class="viewcode-back" href="../../../l2p.html#l2p.utils.pddl_validator.SyntaxValidator.validate_usage_action">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">validate_usage_action</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">llm_response</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">curr_predicates</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Predicate</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">types</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">functions</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Function</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">extract_new_preds</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Higher level function that performs checks over whether the predicates/functions are used in a</span>
<span class="sd">        valid way in the PDDL action. Invokes `validate_pddl_action` to perform deep syntax checks.</span>

<span class="sd">        Args:</span>
<span class="sd">            llm_response (str): raw LLM output</span>
<span class="sd">            curr_predicates (list[predicate]): current predicates in domain</span>
<span class="sd">            types (dict[str,str] | list[dict[str,str]]): current types in domain</span>
<span class="sd">            functions (list[Function]): list of current functions in domain</span>
<span class="sd">            extract_new_preds (bool): flag for if new predicates are being extracted, defaults to False</span>

<span class="sd">        Returns:</span>
<span class="sd">            validation_info (tuple[bool,str]): validation info containing pass flag and error message</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># parse predicates</span>
        <span class="k">if</span> <span class="n">extract_new_preds</span><span class="p">:</span>
            <span class="n">new_predicates</span> <span class="o">=</span> <span class="n">parse_new_predicates</span><span class="p">(</span><span class="n">llm_response</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_predicates</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">curr_predicates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">curr_predicates</span> <span class="o">=</span> <span class="n">new_predicates</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_predicates</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_predicates</span><span class="p">)</span>
        <span class="n">curr_predicates</span> <span class="o">=</span> <span class="n">parse_predicates</span><span class="p">(</span><span class="n">curr_predicates</span><span class="p">)</span>

        <span class="c1"># get action params</span>
        <span class="n">params_info</span> <span class="o">=</span> <span class="n">parse_params</span><span class="p">(</span><span class="n">llm_response</span><span class="p">)</span>

        <span class="c1"># check preconditions</span>
        <span class="n">precond_str</span> <span class="o">=</span> <span class="n">parse_preconditions</span><span class="p">(</span><span class="n">llm_response</span><span class="p">)</span>
        <span class="n">precond_str</span> <span class="o">=</span> <span class="n">remove_comments</span><span class="p">(</span><span class="n">precond_str</span><span class="p">)</span>
        <span class="n">precond_str</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">precond_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot; ( &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="s2">&quot; ) &quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">validation_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_pddl_action</span><span class="p">(</span>
            <span class="n">pddl</span><span class="o">=</span><span class="n">precond_str</span><span class="p">,</span>
            <span class="n">predicates</span><span class="o">=</span><span class="n">curr_predicates</span><span class="p">,</span>
            <span class="n">action_params</span><span class="o">=</span><span class="n">params_info</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">functions</span><span class="o">=</span><span class="n">functions</span><span class="p">,</span>
            <span class="n">types</span><span class="o">=</span><span class="n">types</span><span class="p">,</span>
            <span class="n">part</span><span class="o">=</span><span class="s2">&quot;preconditions&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">validation_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">validation_info</span>

        <span class="c1"># check effects</span>
        <span class="n">eff_str</span> <span class="o">=</span> <span class="n">parse_effects</span><span class="p">(</span><span class="n">llm_response</span><span class="p">)</span>
        <span class="n">eff_str</span> <span class="o">=</span> <span class="n">remove_comments</span><span class="p">(</span><span class="n">eff_str</span><span class="p">)</span>
        <span class="n">eff_str</span> <span class="o">=</span> <span class="n">eff_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot; ( &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="s2">&quot; ) &quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_pddl_action</span><span class="p">(</span>
            <span class="n">pddl</span><span class="o">=</span><span class="n">eff_str</span><span class="p">,</span>
            <span class="n">predicates</span><span class="o">=</span><span class="n">curr_predicates</span><span class="p">,</span>
            <span class="n">action_params</span><span class="o">=</span><span class="n">params_info</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">functions</span><span class="o">=</span><span class="n">functions</span><span class="p">,</span>
            <span class="n">types</span><span class="o">=</span><span class="n">types</span><span class="p">,</span>
            <span class="n">part</span><span class="o">=</span><span class="s2">&quot;effects&quot;</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="c1"># ---- PDDL TASK CHECKS ----</span>

<div class="viewcode-block" id="SyntaxValidator.validate_task_objects">
<a class="viewcode-back" href="../../../l2p.html#l2p.utils.pddl_validator.SyntaxValidator.validate_task_objects">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">validate_task_objects</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">objects</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
        <span class="n">types</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if task objects are declared correctly. Performs the following cases:</span>
<span class="sd">            (i) if object type is found within list of available types</span>
<span class="sd">            (ii) if object name is the same as a type (invalid)</span>

<span class="sd">        Args:</span>
<span class="sd">            objects (dict[str,str]): task objects generated from LLM</span>
<span class="sd">            types (dict[str,str] | list[dict[str,str]]): current types in domain</span>

<span class="sd">        Returns:</span>
<span class="sd">            validation_info (tuple[bool,str]): validation info containing pass flag and error message</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if type hierarchy format</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">types</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">types</span> <span class="o">=</span> <span class="n">format_types</span><span class="p">(</span><span class="n">types</span><span class="p">)</span>

        <span class="n">type_keys</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">types</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">obj_name</span><span class="p">,</span> <span class="n">obj_type</span> <span class="ow">in</span> <span class="n">objects</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="n">obj_type_found</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">for</span> <span class="n">type_key</span> <span class="ow">in</span> <span class="n">type_keys</span><span class="p">:</span>
                <span class="c1"># Try to split into current_type and parent_type if possible</span>
                <span class="k">if</span> <span class="s2">&quot; - &quot;</span> <span class="ow">in</span> <span class="n">type_key</span><span class="p">:</span>
                    <span class="n">current_type</span><span class="p">,</span> <span class="n">parent_type</span> <span class="o">=</span> <span class="n">type_key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; - &quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">current_type</span> <span class="o">=</span> <span class="n">type_key</span>
                    <span class="n">parent_type</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># Match object type to current or parent</span>
                <span class="k">if</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">current_type</span> <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">parent_type</span> <span class="ow">and</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">parent_type</span>
                <span class="p">):</span>
                    <span class="n">obj_type_found</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># Check for name conflict with types</span>
                <span class="k">if</span> <span class="n">obj_name</span> <span class="o">==</span> <span class="n">current_type</span><span class="p">:</span>
                    <span class="n">parsed_line</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">obj_name</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">return</span> <span class="p">(</span>
                        <span class="kc">False</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;[ERROR]: Object variable &#39;</span><span class="si">{</span><span class="n">obj_name</span><span class="si">}</span><span class="s2">&#39; matches the type name &#39;</span><span class="si">{</span><span class="n">current_type</span><span class="si">}</span><span class="s2">&#39;, change it to be unique from types: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">type_keys</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Violated object declaration: (</span><span class="si">{</span><span class="n">parsed_line</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">obj_type</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">obj_name</span><span class="si">}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="n">parent_type</span> <span class="ow">and</span> <span class="n">obj_name</span> <span class="o">==</span> <span class="n">parent_type</span><span class="p">:</span>
                    <span class="n">parsed_line</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">obj_name</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">return</span> <span class="p">(</span>
                        <span class="kc">False</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;[ERROR]: Object variable &#39;</span><span class="si">{</span><span class="n">obj_name</span><span class="si">}</span><span class="s2">&#39; matches the type name &#39;</span><span class="si">{</span><span class="n">parent_type</span><span class="si">}</span><span class="s2">&#39;, change it to be unique from types: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">type_keys</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Violated object declaration: (</span><span class="si">{</span><span class="n">parsed_line</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">obj_type</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">obj_name</span><span class="si">}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="c1"># if object does not contain a type</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">obj_type</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">obj_type_found</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;not found in types: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">type_keys</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">if</span> <span class="n">type_keys</span>
                    <span class="k">else</span> <span class="s2">&quot;but there are no types declared.&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="kc">False</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;[ERROR]: Object variable &#39;</span><span class="si">{</span><span class="n">obj_name</span><span class="si">}</span><span class="s2">&#39; has an invalid type &#39;</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="s2">&#39; </span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;If an object variable requires a type, it must be assigned to the given types. If there are no types, leave object variable untyped.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Parsed line: (</span><span class="si">{</span><span class="n">obj_name</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="n">feedback_msg</span> <span class="o">=</span> <span class="s2">&quot;[PASS]: All objects are valid.&quot;</span>
        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">feedback_msg</span></div>


<div class="viewcode-block" id="SyntaxValidator.validate_task_states">
<a class="viewcode-back" href="../../../l2p.html#l2p.utils.pddl_validator.SyntaxValidator.validate_task_states">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">validate_task_states</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">states</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span>
        <span class="n">objects</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
        <span class="n">predicates</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Predicate</span><span class="p">],</span>
        <span class="n">functions</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Function</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">state_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;initial&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if task states are declared correcly. Performs following checks:</span>
<span class="sd">            (i) if predicates/functions in states exist in the domain</span>
<span class="sd">            (ii) if all object variables in states are declared in task objects</span>
<span class="sd">            (iii) if types of object variables match predicate parameter types</span>

<span class="sd">        Args:</span>
<span class="sd">            states (list[dict[str,str]]): a list of dictionaries of the states</span>
<span class="sd">            objects (dict[str,str]): a dictionary of the task objects and their types</span>
<span class="sd">            predicates (list[Predicate]): current predicates in domain</span>
<span class="sd">            functions (list[Function]): list of current functions in domain</span>
<span class="sd">            state_type (str): optional; &#39;initial&#39; or &#39;goal&#39; to label messages</span>

<span class="sd">        Returns:</span>
<span class="sd">            validation_info (tuple[bool,str]): validation info containing pass flag and error message</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>

            <span class="c1"># new check: function states</span>
            <span class="n">state_name</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;func_name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">state_name</span><span class="p">:</span>
                <span class="n">state_params</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]</span>
                <span class="n">state_val</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
                <span class="n">state_op</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;op&quot;</span><span class="p">]</span>

                <span class="c1"># (i) check if function name exists in domain functions</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">functions</span><span class="p">:</span>
                    <span class="n">functions</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">function_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">state_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">function_names</span><span class="p">:</span>
                    <span class="n">function_names_str</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">function_names</span> <span class="k">if</span> <span class="n">functions</span> <span class="k">else</span> <span class="s2">&quot;No functions provided&quot;</span>
                    <span class="p">)</span>
                    <span class="k">return</span> <span class="p">(</span>
                        <span class="kc">False</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;[ERROR]: In the </span><span class="si">{</span><span class="n">state_type</span><span class="si">}</span><span class="s2"> state, &#39;(</span><span class="si">{</span><span class="n">state_op</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">state_name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">state_params</span><span class="p">)</span><span class="si">}</span><span class="s2">) </span><span class="si">{</span><span class="n">state_val</span><span class="si">}</span><span class="s2">)&#39; &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;uses function &#39;</span><span class="si">{</span><span class="n">state_name</span><span class="si">}</span><span class="s2">&#39;, which is not defined in the domain: </span><span class="si">{</span><span class="n">function_names_str</span><span class="si">}</span><span class="s2">.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;If there are no functions, do not include this state.&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="c1"># (ii) Check if all parameters exist in the task objects</span>
                <span class="n">missing_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">state_params</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">missing_params</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span>
                        <span class="kc">False</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;[ERROR]: In the </span><span class="si">{</span><span class="n">state_type</span><span class="si">}</span><span class="s2"> state, &#39;(</span><span class="si">{</span><span class="n">state_name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">state_params</span><span class="p">)</span><span class="si">}</span><span class="s2">)&#39; &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;contains parameter(s) </span><span class="si">{</span><span class="n">missing_params</span><span class="si">}</span><span class="s2"> not found in task objects </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">objects</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="c1"># (iii) Check if object types match expected predicate types</span>
                <span class="n">target_func</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">functions</span> <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">state_name</span><span class="p">)</span>
                <span class="n">expected_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">target_func</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                <span class="n">actual_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">objects</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">state_params</span><span class="p">]</span>
                <span class="n">actual_name_type_pairs</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s2">&#39; is type: &#39;</span><span class="si">{</span><span class="n">objects</span><span class="p">[</span><span class="n">param</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">state_params</span>
                <span class="p">]</span>

                <span class="k">if</span> <span class="n">expected_types</span> <span class="o">!=</span> <span class="n">actual_types</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span>
                        <span class="kc">False</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;[ERROR]: In the </span><span class="si">{</span><span class="n">state_type</span><span class="si">}</span><span class="s2"> state, &#39;(</span><span class="si">{</span><span class="n">state_op</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">state_name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">state_params</span><span class="p">)</span><span class="si">}</span><span class="s2">) </span><span class="si">{</span><span class="n">state_val</span><span class="si">}</span><span class="s2">)&#39; has mismatched types.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Declared objects: </span><span class="si">{</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">obj_name</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="s1">&#39;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">obj_name</span><span class="p">,</span><span class="w"> </span><span class="n">obj_type</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">objects</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Function `</span><span class="si">{</span><span class="n">target_pred</span><span class="p">[</span><span class="s1">&#39;clean&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">` expects type(s): </span><span class="si">{</span><span class="n">expected_types</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Parsed line: (</span><span class="si">{</span><span class="n">state_op</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">state_name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">state_params</span><span class="p">)</span><span class="si">}</span><span class="s2">) </span><span class="si">{</span><span class="n">state_val</span><span class="si">}</span><span class="s2">) contains type(s): </span><span class="si">{</span><span class="n">actual_types</span><span class="si">}</span><span class="s2">, where [</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">actual_name_type_pairs</span><span class="p">)</span><span class="si">}</span><span class="s2">]</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Revise the state such that their parameter types align with the original function definition types.&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">state_name</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;pred_name&quot;</span><span class="p">]</span>
                <span class="n">state_params</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]</span>

                <span class="c1"># (i) Check if predicate name exists in domain predicates</span>
                <span class="n">predicate_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">predicates</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">state_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">predicate_names</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span>
                        <span class="kc">False</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;[ERROR]: In the </span><span class="si">{</span><span class="n">state_type</span><span class="si">}</span><span class="s2"> state, &#39;(</span><span class="si">{</span><span class="n">state_name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">state_params</span><span class="p">)</span><span class="si">}</span><span class="s2">)&#39; &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;uses predicate &#39;</span><span class="si">{</span><span class="n">state_name</span><span class="si">}</span><span class="s2">&#39;, which is not defined in the domain (</span><span class="si">{</span><span class="n">predicate_names</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="c1"># (ii) Check if all parameters exist in the task objects</span>
                <span class="n">missing_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">state_params</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">missing_params</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span>
                        <span class="kc">False</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;[ERROR]: In the </span><span class="si">{</span><span class="n">state_type</span><span class="si">}</span><span class="s2"> state, &#39;(</span><span class="si">{</span><span class="n">state_name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">state_params</span><span class="p">)</span><span class="si">}</span><span class="s2">)&#39; &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;contains parameter(s) </span><span class="si">{</span><span class="n">missing_params</span><span class="si">}</span><span class="s2"> not found in task objects </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">objects</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="c1"># (iii) Check if object types match expected predicate types</span>
                <span class="n">target_pred</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">predicates</span> <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">state_name</span><span class="p">)</span>
                <span class="n">expected_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">target_pred</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                <span class="n">actual_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">objects</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">state_params</span><span class="p">]</span>
                <span class="n">actual_name_type_pairs</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s2">&#39; is type: &#39;</span><span class="si">{</span><span class="n">objects</span><span class="p">[</span><span class="n">param</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">state_params</span>
                <span class="p">]</span>

                <span class="k">if</span> <span class="n">expected_types</span> <span class="o">!=</span> <span class="n">actual_types</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span>
                        <span class="kc">False</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;[ERROR]: In the </span><span class="si">{</span><span class="n">state_type</span><span class="si">}</span><span class="s2"> state, &#39;(</span><span class="si">{</span><span class="n">state_name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">state_params</span><span class="p">)</span><span class="si">}</span><span class="s2">)&#39; has mismatched types.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Declared objects: </span><span class="si">{</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">obj_name</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="s1">&#39;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">obj_name</span><span class="p">,</span><span class="w"> </span><span class="n">obj_type</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">objects</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Predicate `</span><span class="si">{</span><span class="n">target_pred</span><span class="p">[</span><span class="s1">&#39;clean&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">` expects type(s): </span><span class="si">{</span><span class="n">expected_types</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Parsed line: (</span><span class="si">{</span><span class="n">state_name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">state_params</span><span class="p">)</span><span class="si">}</span><span class="s2">) contains type(s): </span><span class="si">{</span><span class="n">actual_types</span><span class="si">}</span><span class="s2">, where [</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">actual_name_type_pairs</span><span class="p">)</span><span class="si">}</span><span class="s2">]</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Revise the state predicates to match the original predicate parameter types. Do not include type annotations in the predicatee.g., use (drive ?c), not (drive ?c - car).&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="n">feedback_msg</span> <span class="o">=</span> <span class="s2">&quot;[PASS]: All task states are valid.&quot;</span>
        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">feedback_msg</span></div>


    <span class="c1"># ---- COMMON CHECKS ----</span>

<div class="viewcode-block" id="SyntaxValidator.validate_header">
<a class="viewcode-back" href="../../../l2p.html#l2p.utils.pddl_validator.SyntaxValidator.validate_header">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">validate_header</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">llm_response</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if domain headers and formatted code block syntax are found in LLM output.</span>
<span class="sd">        Headers to check must be declared as `self.headers = [&#39;Action Preconditions&#39;]`</span>

<span class="sd">        Args:</span>
<span class="sd">            llm_response (str): raw LLM output</span>

<span class="sd">        Returns:</span>
<span class="sd">            validation_info (tuple[bool,str]): validation info containing pass flag and error message</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># catches if a header is not present</span>
        <span class="k">for</span> <span class="n">header</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">headers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">header</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">llm_response</span><span class="p">:</span>
                <span class="n">feedback_msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[ERROR]: The header `</span><span class="si">{</span><span class="n">header</span><span class="si">}</span><span class="s2">` is missing in the PDDL model. Please include the `### </span><span class="si">{</span><span class="n">header</span><span class="si">}</span><span class="s2">` section following by its content enclosed by [```] like:</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;### </span><span class="si">{</span><span class="n">header</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;```</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;[CONTENT]</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;```&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">feedback_msg</span>

            <span class="c1"># catches if the section does not contain correct code block format</span>
            <span class="k">if</span> <span class="n">llm_response</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">header</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;###&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;```&quot;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">feedback_msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[ERROR]: The header `</span><span class="si">{</span><span class="n">header</span><span class="si">}</span><span class="s2">` contains an incorrect formalised code block. Please include the `### </span><span class="si">{</span><span class="n">header</span><span class="si">}</span><span class="s2">` section following by its content enclosed by [```] like:</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;### </span><span class="si">{</span><span class="n">header</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;```</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;[CONTENT]</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;```&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2"> Source of error may be that keyword `</span><span class="si">{</span><span class="n">header</span><span class="si">}</span><span class="s2">` was used somewhere else. Make sure the header is only stated once in your response.&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">feedback_msg</span>

        <span class="n">feedback_msg</span> <span class="o">=</span> <span class="s2">&quot;[PASS]: headers are identified properly in LLM output.&quot;</span>
        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">feedback_msg</span></div>


<div class="viewcode-block" id="SyntaxValidator.validate_duplicate_headers">
<a class="viewcode-back" href="../../../l2p.html#l2p.utils.pddl_validator.SyntaxValidator.validate_duplicate_headers">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">validate_duplicate_headers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">llm_response</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the LLM attempts to create a new action (so two or more actions defined in the same response).</span>
<span class="sd">        Headers to check must be declared as `self.headers = [&#39;Action Preconditions&#39;]`</span>

<span class="sd">        Args:</span>
<span class="sd">            llm_response (str): raw LLM output</span>

<span class="sd">        Returns:</span>
<span class="sd">            validation_info (tuple[bool,str]): validation info containing pass flag and error message</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">invalid</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">duplicate_headers</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">header</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">headers</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">llm_response</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;### </span><span class="si">{</span><span class="n">header</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">invalid</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">duplicate_headers</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;header&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;`### </span><span class="si">{</span><span class="n">header</span><span class="si">}</span><span class="s2">`&quot;</span><span class="p">,</span> <span class="s2">&quot;count&quot;</span><span class="p">:</span> <span class="n">count</span><span class="p">})</span>

        <span class="k">if</span> <span class="n">invalid</span><span class="p">:</span>
            <span class="n">feedback_msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;[ERROR]: Detected multiple definitions of the following header(s):</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;- </span><span class="si">{</span><span class="n">item</span><span class="p">[</span><span class="s1">&#39;header&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> found </span><span class="si">{</span><span class="n">item</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> times&quot;</span>
                    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">duplicate_headers</span>
                <span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Each header section should only be declared once in your response for: &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;header&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">duplicate_headers</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">feedback_msg</span>

        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;[PASS]: no duplicate sections created.&quot;</span></div>


<div class="viewcode-block" id="SyntaxValidator.validate_unsupported_keywords">
<a class="viewcode-back" href="../../../l2p.html#l2p.utils.pddl_validator.SyntaxValidator.validate_unsupported_keywords">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">validate_unsupported_keywords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">llm_response</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether PDDL model uses unsupported logic keywords</span>
<span class="sd">        Unsupported keywords to check must be declared as `self.unsupported_keywords = [&#39;lisp&#39;]`</span>

<span class="sd">        Args:</span>
<span class="sd">            llm_response (str): raw LLM output</span>

<span class="sd">        Returns:</span>
<span class="sd">            validation_info (tuple[bool,str]): validation info containing pass flag and error message</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">unsupported_keywords</span><span class="p">:</span>
            <span class="n">feedback_msg</span> <span class="o">=</span> <span class="s2">&quot;[PASS]: No unsupported keywords declared.&quot;</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">feedback_msg</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unsupported_keywords</span><span class="p">:</span>
            <span class="k">if</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span> <span class="ow">in</span> <span class="n">llm_response</span><span class="p">:</span>
                <span class="n">feedback_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[ERROR]: The PDDL model contains the keyword `</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">`. Revise the model so that it does not use this keyword.&quot;</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">feedback_msg</span>

        <span class="n">feedback_msg</span> <span class="o">=</span> <span class="s2">&quot;[PASS]: Unsupported keywords not found in PDDL model.&quot;</span>
        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">feedback_msg</span></div>
</div>

</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2025, Marcus Tantakoun
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../../_static/documentation_options.js?v=000c92bf"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/furo.js?v=5fa4622c"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=f281be69"></script>
    </body>
</html>